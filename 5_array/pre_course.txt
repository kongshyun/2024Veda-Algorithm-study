# PRE_COURSE for VER 1 and VER 2

## 1.

구조체 내부에서 배열은 아래의 2가지 형태로 들고 있을 수 있습니다.

1. 배열 형태
    
    ```c
    typedef struct {
        char name[51];
        int age;
    } human_t;
    ```
    
2. 포인터 형태
    
    ```c
    typedef struct {
        char* name;
        int age;
    } human_t;
    ```
    
--------------------------------------------------------------------------
1. 두 구조체 정의에서 `name` 필드가 선언된 방식의 차이는 무엇인가요?
    : 
    [배열형태]
    - 배열형태의 구조체는 메모리 크기가 51바이트로 고정이다. 구조체가 선언되는 시점에 할당됨.
    
    [포인터형태]
    - 포인터 형태의 구조체는 그 자체로 메모리 공간이 할당되있지는 안다. 
    그래서 동적 할당 해야한다. 또한 포인터 크기가 고정.

2. 두 구조체 정의의 메모리 할당 및 관리 방식의 차이점은 무엇인가요?
    : 
    [배열형태]
    - 메모리가 처음에 고정되므로, 메모리 관리를 신경 안써도 된다.
    - 51바이트 이상 문자열을 저장할수 없다.
    - 구조체 전체의 크기가 커진다.

    [포인터형태]
    - 메모리를 동적으로 할당해야한다. 메모리가 필요없을때는 따로 해제 해줘야한다.
    - 필요한 만큼 메모리를 할당할수 있다. 

3. 각 구조체 정의가 어떤 상황에서 유용할 수 있는지 설명하세요.
    :
    [배열형태]
    - 고정된 크기의 문자열 사용시 유용하다. 
    - 또한 따로 추가나 삭제를 안해줘도 되므로 메모리 관리가 단순한 경우에 사용

    [포인터형태]
    - 문자열의 길이가 변동이 많을 때 사용하면 유용하다
    - 메모리를 효율적으로 관리하고 싶을때 유용

4. 두 구조체 정의 중 하나를 사용함에 따라 발생할 수 있는 잠재적 위험이나 주의해야 할 점은 무엇인가요?
    : 
    [배열형태]
    - 안쓰는 메모리까지 쓰고 있으므로, 메모리 낭비가 발생.
    - 크기가 제한되므로 , 버퍼 오버플로우가 발생할수도

    [포인터형태]
    - 동적으로 할당된 메모리는 사용후 반드시 해제해야함. 메모리 누수 발생 할수도있음.
    - 메모리가 올바르게 할당되지 않았으면 NULL을 가리켜야함.
    - 코드가 여러개 필요하다.

